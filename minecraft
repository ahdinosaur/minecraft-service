#!/bin/bash
### BEGIN INIT INFO
# Provides:          minecraft
# Required-Start:    $remote_fs $syslog $network
# Required-Stop:     $remote_fs $syslog $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Minecraft server
# Description:       Service for starting, stopping and checking
#                    the status of a Minecraft server.
### END INIT INFO
#/etc/init.d/minecraft

# Name of script
name=$(basename $0)

# Read configuration variable file if it is present
if [ -r /etc/default/$name ]; then
  source /etc/default/$name
else
  # Default values
  user="minecraft"
  location="/home/$USER/minecraft"
  jar="minecraft_server.jar"
  mem_init="1024M"
  mem_max="1024M"
  java="$(which java)"
  invocation="-Xms$mem_init -Xmx$mem_max -jar $jar nogui"
  desc="Minecraft server"
  fifo="$location/console.input"
  log="$location/console.output"
fi

# Variables
log_line_regex="(\[(..:..:..)\]|....-..-.. (..:..:..)) \[(.*)\]:? (.*)"

# Define LSB log_* functions.
. /lib/lsb/init-functions

# Check user
if [ ! "$(id -u $user)" ]; then
  log_end_msg 1
  exit 1
fi

# Run as specified user
as_user() {
  if [ $(whoami) = $user ]; then
    bash -c "$1"
  else
    su $user /bin/bash -c "$1" || exit 1
  fi
}

server_command() {
  # Usage: server_command "command"
  # Return
  #   0 if command was sent
  
  as_user "echo \"$1\" > $fifo"
  return 0
}

server_is_running() {
  # Return
  #   0 if server is running
  #   1 if server is not running
  
  if [ -z "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid")" ]; then
    return 1
  else
    if [ -z "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid" | grep -v "bash")" ]; then
      return 1
    else
      return 0
    fi
  fi
}

server_reload() {
  # Return
  #   0 if server has been reloaded
  # ( 1 if server could not be reloaded )
  
  server_command "whitelist reload"
  return 0
}

server_start() {
  # Return
  #   0 if server has been started
  #   1 if server could not be started
  
  TIMESTAMP=$(date '+%s')
  
  cd $location || exit 1
  
  # Create fifo if it doesn't exist
  [ -p "$fifo" ] || as_user "mkfifo $fifo"
  
  # Start server
  as_user "tail -n +1 -f --pid=\$$ $fifo | { $java $invocation nuid=$name-nuid &> $log; kill \$$; }" &> /dev/null &
  
  # Wait until current log exists
  echo "   Initializing..."
  until [ -r $log ] && [ $(date +%s -r $log ) -gt $TIMESTAMP ]; do
    sleep 1
  done
  
  # Read log until started
  tail -f $log | while read log_line; do
    
    [[ $log_line =~ $log_line_regex ]]
#   log_line_time="${BASH_REMATCH[2]}${BASH_REMATCH[3]}"
#   log_line_type=${BASH_REMATCH[4]}
    log_line_message=${BASH_REMATCH[5]}
    
    case $log_line in
      *"Done ("*")! For help, type \"help\" or \"?\"")
        kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
        return 0
        ;;
      *"Starting minecraft server version "*)
        ;;
      *"To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"")
        echo "   To start the server with more ram, edit /etc/default/minecraft"
        ;;
      *"**** FAILED TO BIND TO PORT!" | *"You need to agree to the EULA in order to run the server. Go to eula.txt for more info.")
        echo "   $log_line_message"
        server_stop
        kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
        return 1
        ;;
      *)
        [ -z "$log_line_message" ] || echo "   $log_line_message"
        ;;
    esac
    
  done
}

server_stop() {
  # Return
  #   0 if server has been stopped
  #   1 if server could not be stopped
  
  server_command "stop"
  
  # Wait until server is stopped
  while kill -0 "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid" | grep -v "bash" | awk '{print $2}')" &> /dev/null; do
    sleep 1
  done
  
  return 0
}

case "$1" in
  start)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "$desc is already running"
      ;;
      1)
        log_daemon_msg "Starting $desc"
        server_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
    esac
  ;;
  stop)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Stopping $desc"
        server_stop
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
          *) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
  status)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "$desc is running"
        exit 0;
      ;;
      1)
        log_daemon_msg "$desc is not running"
        exit 3;
      ;;
    esac
  ;;
  reload)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Reloading $desc whitelist"
        server_reload
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
  restart|force-reload)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Restarting $desc"
        server_stop
        case "$?" in
          0)
            log_daemon_msg "$desc stopped, starting again"
            server_start
            case "$?" in
              0) log_end_msg 0 ;;
              1) log_end_msg 1; exit 1 ;;
            esac
          ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "Starting $desc"
        server_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
    esac
  ;;
  *)
    echo "Usage: service $name {start|stop|status|restart|reload}" >&2
    exit 3
  ;;
esac
exit 0