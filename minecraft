#!/bin/bash
### BEGIN INIT INFO
# Provides:          minecraft
# Required-Start:    $remote_fs $syslog $network
# Required-Stop:     $remote_fs $syslog $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Minecraft server
# Description:       Service for starting, stopping and checking
#                    the status of a Minecraft server.
### END INIT INFO
#/etc/init.d/minecraft

# Name and (real)location of script
name=$(basename $0)
scriptpath="$(dirname "$(readlink -f "$0")")"

# Read configuration variable file if it is present
if [ -r /etc/default/$name ]; then
  source /etc/default/$name
else
  # Default values
  user="minecraft"
  location="/home/$USER/minecraft"
  jar="minecraft_server.jar"
  mem_init="1024M"
  mem_max="1024M"
  java="$(which java)"
  invocation="-Xms$mem_init -Xmx$mem_max -jar $jar nogui"
  desc="Minecraft server"
  fifo="$location/console.input"
  log="$location/console.output"
fi

# Variables
log_line_regex="(\[(..:..:..)\]|....-..-.. (..:..:..)) \[(.*)\]:? (.*)"

# Define LSB log_* functions.
. /lib/lsb/init-functions

# Check user
if [ ! "$(id -u $user)" ]; then
  log_end_msg 1
  exit 1
fi

# Run as specified user
as_user() {
  if [ $(whoami) = $user ]; then
    bash -c "$1"
  else
    sudo -u $user /bin/bash -c "$1" || exit 1
  fi
}

# Test if a value can be found in an array
in_array() {
  # Usage
  #   in_array "value" "${array_containing_values[@]}"
  # Return
  #   0 if value (or beginning of value) was found in array
  #   1 if value (or beginning of value) was not found in array
  local v
  for v in "${@:2}"; do
    [[ "$1" == "$e"* ]] && return 0
  done
  return 1
}

server_command() {
  # Usage
  #   server_command [-f] "<command>" "<response from server> (optional)"
  # Return
  #   0 if command was sent successfully
  
  local timestamp
  
  while getopts :f opt; do
    case $opt in
      f)
        force=true
        ;;
    esac
  done
  shift $((OPTIND-1))
  
  # Possible responses for specified commands (when completed).
  # If this is filled, it gives a more certain return from function.
  # Otherwise it just returns the latest message from server (which
  # can be something else than a response to a specific command).
  case "$1" in
    "ban "*)
      message=(
        "CONSOLE: Banning "
        "Banned player "        # 1.3.1 (1.3) and later
        "Could not ban player " # 1.7.9 and later
      )
      ;;
    "ban-ip "*)
      message=(
        "CONSOLE: Banning ip "
        "Banned IP address "    # 1.3.1 (1.3) and later
      )
      ;;
    "pardon")
      message=(
        "CONSOLE: Pardoning "
        "Unbanned player "        # 1.3.1 (1.3) and later
        "Could not unban player " # 1.7.9 (14w10c) and later
      )
      ;;
    "save-all")
      message=(
        "CONSOLE: Save complete."
        "Saved the world"         # 1.3.1 (1.3) and later
      )
      ;;
    "save-off")
      message=(
        "CONSOLE: Disabling level saving.."
        "Turned off world auto-saving"      # 1.3.1 (1.3) and later 
        "Saving is already turned off."     # 1.6.1 (1.6) and later
      )
      ;;
    "save-on")
      message=(
        "CONSOLE: Enabling level saving.."
        "Turned on world auto-saving"      # 1.3.1 (1.3) and later 
        "Saving is already turned on."     # 1.6.1 (1.6) and later
      )
      ;;
    *)
      message=(${@:2})
      ;;
  esac
  
  # Possible responses to unknown command
  unknown=(
    "Unknown console command. Type \"help\" for help."
    "Unknown command. Try /help for a list of commands" # 1.3.1 (1.3) and later
  )
  
  timestamp=$(date +%s)
  
  as_user "echo \"$1\" > $fifo"
  
  tail -n 5 -f $log | while read log_line; do
    
    [[ $log_line =~ $log_line_regex ]]
    
    log_line_time="${BASH_REMATCH[2]}${BASH_REMATCH[3]}"
    log_line_message=${BASH_REMATCH[5]}
    
    # Create log timestamp from log time in hh:mm:ss + todays date
    IFS=: read h m s <<< "$log_line_time"
    todays_time=$((10#$h * 3600 + 10#$m * 60 + 10#$s))
    todays_date=$(date -d "$(date +%F)" +%s)
    log_line_time_seconds=$(($todays_date + $todays_time))
    
    # If log timestamp is less than our reference timestamp, skip iteration
    if [ $log_line_time_seconds -lt $timestamp ]; then
      continue
    fi
    
    # Message
    if [ ! -z "$force" ]; then
      kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
      return 0
    elif [ -z "$message" ]; then
      echo $log_line_message
      kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
      return 0
    elif in_array "$log_line_message" "${message[@]}"; then
      echo $log_line_message
      kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
      return 0
    elif in_array "$log_line_message" "${unknown[@]}"; then
      echo $log_line_message
      kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
      return 1
    fi

  done
}

server_is_running() {
  # Return
  #   0 if server is running
  #   1 if server is not running
  
  if [ -z "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid")" ]; then
    return 1
  else
    if [ -z "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid" | grep -v "bash")" ]; then
      return 1
    else
      return 0
    fi
  fi
}

server_reload() {
  # Return
  #   0 if server has been reloaded
  # ( 1 if server could not be reloaded )
  
  server_command "whitelist reload"
  return 0
}

server_start() {
  # Return
  #   0 if server has been started
  #   1 if server could not be started
  local timestamp
  
  timestamp=$(date '+%s')
  
  cd $location || exit 1
  
  # Create fifo if it doesn't exist
  [ -p "$fifo" ] || as_user "mkfifo $fifo"
  
  # Start server
  as_user "tail -n +1 -f --pid=\$$ $fifo | { $java $invocation nuid=$name-nuid &> $log; kill \$$; }" &> /dev/null &
  
  # Wait until current log exists
  echo "   Initializing..."
  until [ -r $log ] && [ $(date +%s -r $log ) -gt $timestamp ]; do
    sleep 1
  done
  
  # Read log until started
  tail -f $log | while read log_line; do
    
    [[ $log_line =~ $log_line_regex ]]
#   log_line_time="${BASH_REMATCH[2]}${BASH_REMATCH[3]}"
#   log_line_type=${BASH_REMATCH[4]}
    log_line_message=${BASH_REMATCH[5]}
    
    case $log_line in
      *"Done ("*")! For help, type \"help\" or \"?\"")
        kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
        return 0
        ;;
      *"Starting minecraft server version "*)
        echo "   Server version: ${log_line_message#*version }"
        ;;
      *"To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"")
        echo "   To start the server with more ram, edit /etc/default/minecraft"
        ;;
      *"**** FAILED TO BIND TO PORT!" | *"You need to agree to the EULA in order to run the server. Go to eula.txt for more info.")
        echo "   $log_line_message"
        server_stop
        kill $(ps -o pid,cmd --no-headers --ppid $$ | grep tail | awk '{print $1}')
        return 1
        ;;
      *)
        [ -z "$log_line_message" ] || echo "   $log_line_message"
        ;;
    esac
    
  done
}

server_stop() {
  # Return
  #   0 if server has been stopped
  #   1 if server could not be stopped
  
  server_command -f "stop"
  
  # Sleep until server is stopped
  while kill -0 "$(ps -aux | grep -v grep | grep "$java.*nuid=$name-nuid" | grep -v "bash" | awk '{print $2}')" &> /dev/null; do
    sleep 1
  done
  
  return 0
}

case "$1" in
  start)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "$desc is already running"
      ;;
      1)
        log_daemon_msg "Starting $desc"
        server_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
    esac
  ;;
  stop)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Stopping $desc"
        server_stop
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
          *) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
  status)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "$desc is running"
        exit 0;
      ;;
      1)
        log_daemon_msg "$desc is not running"
        exit 3;
      ;;
    esac
  ;;
  reload)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Reloading $desc whitelist"
        server_reload
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
  restart|force-reload)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Restarting $desc"
        server_stop
        case "$?" in
          0)
            log_daemon_msg "$desc stopped, starting again"
            server_start
            case "$?" in
              0) log_end_msg 0 ;;
              1) log_end_msg 1; exit 1 ;;
            esac
          ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "Starting $desc"
        server_start
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
        esac
      ;;
    esac
  ;;
# Special commands
  backup)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Backing up $desc"
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
  command)
    server_is_running
    case "$?" in
      0)
        log_daemon_msg "Sending command to $desc"
        server_command "${*:2}"
        case "$?" in
          0) log_end_msg 0 ;;
          1) log_end_msg 1; exit 1 ;;
          *) log_end_msg 1; exit 1 ;;
        esac
      ;;
      1)
        log_daemon_msg "$desc is not running"
      ;;
    esac
  ;;
# Catch all
  *)
    echo "Usage: service $name {start|stop|status|restart|reload}" >&2
    exit 3
  ;;
esac
exit 0